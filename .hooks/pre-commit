#!/bin/bash
# UnaMentis Pre-Commit Hook
# This hook runs quality checks on staged files before allowing commits.
# Install with: ./scripts/install-hooks.sh

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# =============================================================================
# Bypass Logging
# =============================================================================
# Log directory for hook audit trail
HOOK_LOG_DIR="${HOME}/.unamentis/hook-logs"
mkdir -p "$HOOK_LOG_DIR"

# Log that the hook ran (helps identify when bypasses occur)
log_hook_execution() {
    local status=$1
    local log_file="${HOOK_LOG_DIR}/pre-commit.log"
    local timestamp=$(date -u +'%Y-%m-%dT%H:%M:%SZ')
    local branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "unknown")
    local commit_msg_file="${GIT_DIR:-$(git rev-parse --git-dir)}/COMMIT_EDITMSG"

    # Rotate log if over 1MB
    if [ -f "$log_file" ] && [ $(stat -f%z "$log_file" 2>/dev/null || stat -c%s "$log_file" 2>/dev/null || echo 0) -gt 1048576 ]; then
        mv "$log_file" "${log_file}.1"
    fi

    echo "${timestamp}|${status}|${branch}|$(whoami)|$$" >> "$log_file"
}

# Log hook start
log_hook_execution "STARTED"

echo -e "${YELLOW}Running pre-commit checks...${NC}"

# Track if any checks fail
FAILED=0

# Get list of staged files
STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACM)

if [ -z "$STAGED_FILES" ]; then
    echo -e "${GREEN}No staged files to check.${NC}"
    exit 0
fi

# =============================================================================
# Swift Checks (iOS)
# =============================================================================
SWIFT_FILES=$(echo "$STAGED_FILES" | grep -E '\.swift$' || true)

if [ -n "$SWIFT_FILES" ]; then
    echo -e "\n${YELLOW}Checking Swift files...${NC}"

    # Check if SwiftLint is available
    if command -v swiftlint &> /dev/null; then
        echo "Running SwiftLint..."
        # Lint only staged Swift files
        echo "$SWIFT_FILES" | xargs swiftlint lint --quiet --strict || {
            echo -e "${RED}SwiftLint found violations. Please fix them before committing.${NC}"
            FAILED=1
        }
    else
        echo -e "${YELLOW}SwiftLint not found, skipping Swift lint checks.${NC}"
    fi

    # Check if SwiftFormat is available (check mode only)
    if command -v swiftformat &> /dev/null; then
        echo "Running SwiftFormat check..."
        echo "$SWIFT_FILES" | xargs swiftformat --lint || {
            echo -e "${RED}SwiftFormat found formatting issues. Run 'swiftformat .' to fix.${NC}"
            FAILED=1
        }
    fi
fi

# =============================================================================
# Python Checks (Server)
# =============================================================================
PYTHON_FILES=$(echo "$STAGED_FILES" | grep -E '\.py$' || true)

if [ -n "$PYTHON_FILES" ]; then
    echo -e "\n${YELLOW}Checking Python files...${NC}"

    # Check if ruff is available
    if command -v ruff &> /dev/null; then
        echo "Running Ruff..."
        echo "$PYTHON_FILES" | xargs ruff check --quiet || {
            echo -e "${RED}Ruff found violations. Please fix them before committing.${NC}"
            FAILED=1
        }

        echo "Running Ruff format check..."
        echo "$PYTHON_FILES" | xargs ruff format --check --quiet || {
            echo -e "${RED}Ruff found formatting issues. Run 'ruff format .' to fix.${NC}"
            FAILED=1
        }
    else
        echo -e "${YELLOW}Ruff not found, skipping Python lint checks.${NC}"
    fi
fi

# =============================================================================
# Python Security Scan (Bandit)
# =============================================================================
# Bandit catches security issues like command injection, hardcoded passwords,
# unsafe pickle use, etc. Note: Path injection is caught by CodeQL in CI.
if [ -n "$PYTHON_FILES" ]; then
    if command -v bandit &> /dev/null; then
        echo -e "\n${YELLOW}Running Python security scan (Bandit)...${NC}"
        echo "$PYTHON_FILES" | xargs bandit -q -ll 2>/dev/null || {
            echo -e "${RED}Bandit found security issues. Please fix them before committing.${NC}"
            FAILED=1
        }
    fi
fi

# =============================================================================
# Python Coverage Check (Management Server)
# =============================================================================
MANAGEMENT_PYTHON_FILES=$(echo "$STAGED_FILES" | grep -E '^server/management/.*\.py$' || true)
# Exclude test files from the check trigger
MANAGEMENT_NON_TEST_FILES=$(echo "$MANAGEMENT_PYTHON_FILES" | grep -v '/tests/' || true)

if [ -n "$MANAGEMENT_NON_TEST_FILES" ]; then
    echo -e "\n${YELLOW}Checking Python test coverage (server/management)...${NC}"

    # Find pytest
    PYTEST_CMD=""
    if [ -f "$HOME/Library/Python/3.9/bin/pytest" ]; then
        PYTEST_CMD="$HOME/Library/Python/3.9/bin/pytest"
    elif command -v pytest &> /dev/null; then
        PYTEST_CMD="pytest"
    fi

    if [ -n "$PYTEST_CMD" ] && [ -d "server/management" ]; then
        cd server/management

        # Set PYTHONPATH to include server directory for latency_harness imports
        export PYTHONPATH="${PWD}/..:${PYTHONPATH}"

        echo "Running pytest with coverage (80% minimum required)..."
        if ! "$PYTEST_CMD" tests/ --cov=. --cov-report=term --cov-fail-under=80 -q 2>&1; then
            echo -e "${RED}Coverage check failed! Coverage must be at least 80%.${NC}"
            echo -e "${YELLOW}Run 'pytest tests/ --cov=. --cov-report=term' in server/management to see details.${NC}"
            FAILED=1
        else
            echo -e "${GREEN}Coverage check passed (80%+ achieved).${NC}"
        fi

        cd - > /dev/null
    else
        echo -e "${YELLOW}pytest not found, skipping coverage check.${NC}"
    fi
fi

# =============================================================================
# iOS/Swift Coverage Check
# =============================================================================
IOS_SWIFT_FILES=$(echo "$STAGED_FILES" | grep -E '^UnaMentis/.*\.swift$' || true)
# Exclude test files and UI-only files from triggering coverage check
IOS_NON_TEST_FILES=$(echo "$IOS_SWIFT_FILES" | grep -v 'Tests/' | grep -v '/Views/' || true)

if [ -n "$IOS_NON_TEST_FILES" ]; then
    echo -e "\n${YELLOW}Checking iOS test coverage...${NC}"

    # Check if xcodebuild is available
    if command -v xcodebuild &> /dev/null; then
        # Check if test-ci.sh exists and run quick unit tests with coverage enforcement
        if [ -f "scripts/test-ci.sh" ]; then
            echo "Running iOS unit tests with coverage enforcement (80% minimum)..."
            # Run tests with coverage enforcement enabled
            if ! ENFORCE_COVERAGE=true TEST_TYPE=unit ./scripts/test-ci.sh 2>&1 | tail -20; then
                echo -e "${RED}iOS coverage check failed! Coverage must be at least 80%.${NC}"
                echo -e "${YELLOW}Run './scripts/test-quick.sh' to see full test output.${NC}"
                FAILED=1
            else
                echo -e "${GREEN}iOS coverage check passed (80%+ achieved).${NC}"
            fi
        else
            echo -e "${YELLOW}test-ci.sh not found, skipping iOS coverage check.${NC}"
        fi
    else
        echo -e "${YELLOW}xcodebuild not found, skipping iOS coverage check.${NC}"
    fi
fi

# =============================================================================
# JavaScript/TypeScript Checks (Web)
# =============================================================================
JS_TS_FILES=$(echo "$STAGED_FILES" | grep -E '\.(js|jsx|ts|tsx)$' || true)
WEB_JS_TS_FILES=$(echo "$JS_TS_FILES" | grep -E '^server/web/' || true)

if [ -n "$WEB_JS_TS_FILES" ]; then
    echo -e "\n${YELLOW}Checking JavaScript/TypeScript files...${NC}"

    # Check from web directory
    if [ -d "server/web" ]; then
        cd server/web

        # Check if eslint is available via npx
        if [ -f "package.json" ] && command -v npx &> /dev/null; then
            echo "Running ESLint..."
            # Get relative paths for the web directory
            WEB_RELATIVE_FILES=$(echo "$WEB_JS_TS_FILES" | sed 's|^server/web/||')
            echo "$WEB_RELATIVE_FILES" | xargs npx eslint --quiet || {
                echo -e "${RED}ESLint found violations. Please fix them before committing.${NC}"
                FAILED=1
            }

            echo "Running Prettier check..."
            echo "$WEB_RELATIVE_FILES" | xargs npx prettier --check || {
                echo -e "${RED}Prettier found formatting issues. Run 'npm run format' to fix.${NC}"
                FAILED=1
            }
        fi

        cd - > /dev/null
    fi
fi

# =============================================================================
# Secrets Detection (All Files)
# =============================================================================
if command -v gitleaks &> /dev/null; then
    echo -e "\n${YELLOW}Checking for secrets...${NC}"
    gitleaks detect --staged --no-banner --quiet || {
        echo -e "${RED}Gitleaks found potential secrets. Please remove them before committing.${NC}"
        FAILED=1
    }
fi

# =============================================================================
# Final Result
# =============================================================================
echo ""
if [ $FAILED -eq 1 ]; then
    log_hook_execution "FAILED"
    echo -e "${RED}Pre-commit checks failed. Please fix the issues above.${NC}"
    echo -e "${YELLOW}Tip: You can bypass this check with 'git commit --no-verify' (not recommended)${NC}"
    echo -e "${YELLOW}Note: Hook bypasses are logged for audit purposes.${NC}"
    exit 1
else
    log_hook_execution "PASSED"
    echo -e "${GREEN}All pre-commit checks passed!${NC}"
    exit 0
fi
