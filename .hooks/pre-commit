#!/bin/bash
# UnaMentis Pre-Commit Hook
# This hook runs quality checks on staged files before allowing commits.
# Install with: ./scripts/install-hooks.sh

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# =============================================================================
# Bypass Logging
# =============================================================================
# Log directory for hook audit trail
HOOK_LOG_DIR="${HOME}/.unamentis/hook-logs"
mkdir -p "$HOOK_LOG_DIR"

# Log that the hook ran (helps identify when bypasses occur)
log_hook_execution() {
    local status=$1
    local log_file="${HOOK_LOG_DIR}/pre-commit.log"
    local timestamp=$(date -u +'%Y-%m-%dT%H:%M:%SZ')
    local branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "unknown")
    local commit_msg_file="${GIT_DIR:-$(git rev-parse --git-dir)}/COMMIT_EDITMSG"

    # Rotate log if over 1MB
    if [ -f "$log_file" ] && [ $(stat -f%z "$log_file" 2>/dev/null || stat -c%s "$log_file" 2>/dev/null || echo 0) -gt 1048576 ]; then
        mv "$log_file" "${log_file}.1"
    fi

    echo "${timestamp}|${status}|${branch}|$(whoami)|$$" >> "$log_file"
}

# Log hook start
log_hook_execution "STARTED"

echo -e "${YELLOW}Running pre-commit checks...${NC}"

# Track if any checks fail
FAILED=0

# Get list of staged files
STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACM)

if [ -z "$STAGED_FILES" ]; then
    echo -e "${GREEN}No staged files to check.${NC}"
    exit 0
fi

# =============================================================================
# Swift Checks (iOS)
# =============================================================================
SWIFT_FILES=$(echo "$STAGED_FILES" | grep -E '\.swift$' || true)

if [ -n "$SWIFT_FILES" ]; then
    echo -e "\n${YELLOW}Checking Swift files...${NC}"

    # Check if SwiftLint is available
    if command -v swiftlint &> /dev/null; then
        echo "Running SwiftLint..."
        # Lint only staged Swift files
        echo "$SWIFT_FILES" | xargs swiftlint lint --quiet --strict || {
            echo -e "${RED}SwiftLint found violations. Please fix them before committing.${NC}"
            FAILED=1
        }
    else
        echo -e "${YELLOW}SwiftLint not found, skipping Swift lint checks.${NC}"
    fi

    # Check if SwiftFormat is available (check mode only)
    if command -v swiftformat &> /dev/null; then
        echo "Running SwiftFormat check..."
        echo "$SWIFT_FILES" | xargs swiftformat --lint || {
            echo -e "${RED}SwiftFormat found formatting issues. Run 'swiftformat .' to fix.${NC}"
            FAILED=1
        }
    fi
fi

# =============================================================================
# Swift Mock Test Violation Detection (Prevention)
# =============================================================================
# Enforces "Real Over Mock" philosophy for Swift tests
# Approved mocks for paid external APIs must be in MockServices.swift only

SWIFT_TEST_FILES=$(echo "$STAGED_FILES" | grep -E '^UnaMentisTests/.*\.swift$' || true)
# Exclude MockServices.swift which is the approved location for external API mocks
SWIFT_TEST_FILES_NO_MOCKS=$(echo "$SWIFT_TEST_FILES" | grep -v 'MockServices\.swift$' || true)

if [ -n "$SWIFT_TEST_FILES_NO_MOCKS" ]; then
    echo -e "\n${YELLOW}Checking for Swift mock test violations...${NC}"

    SWIFT_MOCK_VIOLATIONS=""

    for file in $SWIFT_TEST_FILES_NO_MOCKS; do
        staged_content=$(git show ":$file" 2>/dev/null || true)

        if [ -n "$staged_content" ]; then
            # Detect class Mock*, actor Mock*, struct Mock* definitions
            violations=$(echo "$staged_content" | grep -n "^\(class\|actor\|struct\) Mock" | grep -v "// ALLOWED:" || true)
            if [ -n "$violations" ]; then
                SWIFT_MOCK_VIOLATIONS="${SWIFT_MOCK_VIOLATIONS}\n${file}:\n${violations}"
            fi
        fi
    done

    if [ -n "$SWIFT_MOCK_VIOLATIONS" ]; then
        echo -e "${RED}Swift mock test violations detected!${NC}"
        echo -e "${YELLOW}Mock definitions found outside MockServices.swift:${NC}"
        echo -e "$SWIFT_MOCK_VIOLATIONS"
        echo ""
        echo -e "${YELLOW}TESTING PHILOSOPHY: Real Over Mock${NC}"
        echo "Mocks are only allowed for paid external APIs (LLM, STT, TTS, Embeddings)."
        echo ""
        echo "Options:"
        echo "  1. Use real implementations (preferred)"
        echo "  2. Add approved mock to UnaMentisTests/Helpers/MockServices.swift"
        echo ""
        echo "See: AGENTS.md for full testing philosophy"
        echo ""
        echo "If this is a legitimate exception, add '// ALLOWED: <reason>' comment on the same line"
        FAILED=1
    else
        echo -e "${GREEN}No Swift mock violations detected.${NC}"
    fi
fi

# =============================================================================
# Python Checks (Server)
# =============================================================================
PYTHON_FILES=$(echo "$STAGED_FILES" | grep -E '\.py$' || true)

if [ -n "$PYTHON_FILES" ]; then
    echo -e "\n${YELLOW}Checking Python files...${NC}"

    # Check if ruff is available
    if command -v ruff &> /dev/null; then
        echo "Running Ruff..."
        echo "$PYTHON_FILES" | xargs ruff check --quiet || {
            echo -e "${RED}Ruff found violations. Please fix them before committing.${NC}"
            FAILED=1
        }

        echo "Running Ruff format check..."
        echo "$PYTHON_FILES" | xargs ruff format --check --quiet || {
            echo -e "${RED}Ruff found formatting issues. Run 'ruff format .' to fix.${NC}"
            FAILED=1
        }
    else
        echo -e "${YELLOW}Ruff not found, skipping Python lint checks.${NC}"
    fi
fi

# =============================================================================
# Python Security Scan (Bandit)
# =============================================================================
# Bandit catches security issues like command injection, hardcoded passwords,
# unsafe pickle use, etc. Note: Path injection is caught by CodeQL in CI.
if [ -n "$PYTHON_FILES" ]; then
    if command -v bandit &> /dev/null; then
        echo -e "\n${YELLOW}Running Python security scan (Bandit)...${NC}"
        echo "$PYTHON_FILES" | xargs bandit -q -ll 2>/dev/null || {
            echo -e "${RED}Bandit found security issues. Please fix them before committing.${NC}"
            FAILED=1
        }
    fi
fi

# =============================================================================
# Python Mock Test Violation Detection
# =============================================================================
# Enforces "Real Over Mock" philosophy - see AGENTS.md
# Detects forbidden mock patterns in staged Python test files

PYTHON_TEST_FILES=$(echo "$STAGED_FILES" | grep -E '^server/(management|importers)/.*tests?/.*\.py$' || true)

if [ -n "$PYTHON_TEST_FILES" ]; then
    echo -e "\n${YELLOW}Checking for Python mock test violations...${NC}"

    MOCK_VIOLATIONS=""

    for file in $PYTHON_TEST_FILES; do
        # Use git show to get staged content (not working directory)
        staged_content=$(git show ":$file" 2>/dev/null || true)

        if [ -n "$staged_content" ]; then
            # Pattern 1: Detect class Mock* definitions (except # ALLOWED: comments)
            class_violations=$(echo "$staged_content" | grep -n "^class Mock" | grep -v "# ALLOWED:" || true)
            if [ -n "$class_violations" ]; then
                MOCK_VIOLATIONS="${MOCK_VIOLATIONS}\n${file} (Mock class definitions):\n${class_violations}"
            fi

            # Pattern 2: Detect MagicMock()/AsyncMock() variable assignments
            mock_assignments=$(echo "$staged_content" | grep -n "= \(MagicMock\|AsyncMock\)()" | grep -v "# ALLOWED:" || true)
            if [ -n "$mock_assignments" ]; then
                MOCK_VIOLATIONS="${MOCK_VIOLATIONS}\n${file} (MagicMock/AsyncMock assignments):\n${mock_assignments}"
            fi
        fi
    done

    if [ -n "$MOCK_VIOLATIONS" ]; then
        echo -e "${RED}Python mock test violations detected!${NC}"
        echo -e "${YELLOW}The following forbidden mock patterns were found:${NC}"
        echo -e "$MOCK_VIOLATIONS"
        echo ""
        echo -e "${YELLOW}TESTING PHILOSOPHY: Real Over Mock${NC}"
        echo "Mocks are only allowed for paid external APIs (LLM, STT, TTS, Embeddings)."
        echo ""
        echo "Instead of mocking internal services:"
        echo "  - Use real_tts_cache fixture with tmp_path"
        echo "  - Use real_db or in_memory_db fixtures"
        echo "  - Use real_resource_pool with aioresponses for HTTP"
        echo ""
        echo "See: AGENTS.md for full testing philosophy"
        echo "See: docs/testing/MOCK_VIOLATIONS_INVENTORY.md for remediation patterns"
        echo ""
        echo "If this is a legitimate exception, add '# ALLOWED: <reason>' comment on the same line"
        FAILED=1
    else
        echo -e "${GREEN}No Python mock violations detected.${NC}"
    fi
fi

# =============================================================================
# Python Coverage Check (Management Server)
# =============================================================================
MANAGEMENT_PYTHON_FILES=$(echo "$STAGED_FILES" | grep -E '^server/management/.*\.py$' || true)
# Exclude test files from the check trigger
MANAGEMENT_NON_TEST_FILES=$(echo "$MANAGEMENT_PYTHON_FILES" | grep -v '/tests/' || true)

if [ -n "$MANAGEMENT_NON_TEST_FILES" ]; then
    echo -e "\n${YELLOW}Checking Python test coverage (server/management)...${NC}"

    # Find pytest
    PYTEST_CMD=""
    if [ -f "$HOME/Library/Python/3.9/bin/pytest" ]; then
        PYTEST_CMD="$HOME/Library/Python/3.9/bin/pytest"
    elif command -v pytest &> /dev/null; then
        PYTEST_CMD="pytest"
    fi

    if [ -n "$PYTEST_CMD" ] && [ -d "server/management" ]; then
        cd server/management

        # Set PYTHONPATH to include server directory for latency_harness imports
        export PYTHONPATH="${PWD}/..:${PYTHONPATH}"

        echo "Running pytest with coverage (80% minimum required)..."
        if ! "$PYTEST_CMD" tests/ --cov=. --cov-report=term --cov-fail-under=80 -q 2>&1; then
            echo -e "${RED}Coverage check failed! Coverage must be at least 80%.${NC}"
            echo -e "${YELLOW}Run 'pytest tests/ --cov=. --cov-report=term' in server/management to see details.${NC}"
            FAILED=1
        else
            echo -e "${GREEN}Coverage check passed (80%+ achieved).${NC}"
        fi

        cd - > /dev/null
    else
        echo -e "${YELLOW}pytest not found, skipping coverage check.${NC}"
    fi
fi

# =============================================================================
# iOS/Swift Coverage Check
# =============================================================================
IOS_SWIFT_FILES=$(echo "$STAGED_FILES" | grep -E '^UnaMentis/.*\.swift$' || true)
# Exclude test files and UI-only files from triggering coverage check
IOS_NON_TEST_FILES=$(echo "$IOS_SWIFT_FILES" | grep -v 'Tests/' | grep -v '/Views/' || true)

if [ -n "$IOS_NON_TEST_FILES" ]; then
    echo -e "\n${YELLOW}Checking iOS test coverage...${NC}"

    # Check if xcodebuild is available
    if command -v xcodebuild &> /dev/null; then
        # Check if test-ci.sh exists and run quick unit tests with coverage enforcement
        if [ -f "scripts/test-ci.sh" ]; then
            echo "Running iOS unit tests with coverage enforcement (80% minimum)..."
            # Run tests with coverage enforcement enabled
            if ! ENFORCE_COVERAGE=true TEST_TYPE=unit ./scripts/test-ci.sh 2>&1 | tail -20; then
                echo -e "${RED}iOS coverage check failed! Coverage must be at least 80%.${NC}"
                echo -e "${YELLOW}Run './scripts/test-quick.sh' to see full test output.${NC}"
                FAILED=1
            else
                echo -e "${GREEN}iOS coverage check passed (80%+ achieved).${NC}"
            fi
        else
            echo -e "${YELLOW}test-ci.sh not found, skipping iOS coverage check.${NC}"
        fi
    else
        echo -e "${YELLOW}xcodebuild not found, skipping iOS coverage check.${NC}"
    fi
fi

# =============================================================================
# JavaScript/TypeScript Checks (Web)
# =============================================================================
JS_TS_FILES=$(echo "$STAGED_FILES" | grep -E '\.(js|jsx|ts|tsx)$' || true)
WEB_JS_TS_FILES=$(echo "$JS_TS_FILES" | grep -E '^server/web/' || true)

if [ -n "$WEB_JS_TS_FILES" ]; then
    echo -e "\n${YELLOW}Checking JavaScript/TypeScript files...${NC}"

    # Check from web directory
    if [ -d "server/web" ]; then
        cd server/web

        # Check if eslint is available via npx
        if [ -f "package.json" ] && command -v npx &> /dev/null; then
            echo "Running ESLint..."
            # Get relative paths for the web directory
            WEB_RELATIVE_FILES=$(echo "$WEB_JS_TS_FILES" | sed 's|^server/web/||')
            echo "$WEB_RELATIVE_FILES" | xargs npx eslint --quiet || {
                echo -e "${RED}ESLint found violations. Please fix them before committing.${NC}"
                FAILED=1
            }

            echo "Running Prettier check..."
            echo "$WEB_RELATIVE_FILES" | xargs npx prettier --check || {
                echo -e "${RED}Prettier found formatting issues. Run 'npm run format' to fix.${NC}"
                FAILED=1
            }
        fi

        cd - > /dev/null
    fi
fi

# =============================================================================
# TypeScript Mock Test Violation Detection
# =============================================================================
# Enforces "Real Over Mock" philosophy for TypeScript tests
# vi.mock for internal modules should be replaced with MSW

WEB_TEST_FILES=$(echo "$STAGED_FILES" | grep -E '^server/web/.*\.test\.(ts|tsx)$' || true)

if [ -n "$WEB_TEST_FILES" ]; then
    echo -e "\n${YELLOW}Checking for TypeScript mock test violations...${NC}"

    TS_MOCK_VIOLATIONS=""

    for file in $WEB_TEST_FILES; do
        staged_content=$(git show ":$file" 2>/dev/null || true)

        if [ -n "$staged_content" ]; then
            # Detect vi.mock('@/lib/...) pattern for internal modules
            violations=$(echo "$staged_content" | grep -n "vi\.mock.*@/lib" | grep -v "// ALLOWED:" || true)
            if [ -n "$violations" ]; then
                TS_MOCK_VIOLATIONS="${TS_MOCK_VIOLATIONS}\n${file}:\n${violations}"
            fi
        fi
    done

    if [ -n "$TS_MOCK_VIOLATIONS" ]; then
        echo -e "${RED}TypeScript mock test violations detected!${NC}"
        echo -e "${YELLOW}The following vi.mock patterns should use MSW instead:${NC}"
        echo -e "$TS_MOCK_VIOLATIONS"
        echo ""
        echo "Replace vi.mock with MSW (Mock Service Worker):"
        echo "  import { setupServer } from 'msw/node';"
        echo "  import { http, HttpResponse } from 'msw';"
        echo ""
        echo "See: docs/testing/MOCK_VIOLATIONS_INVENTORY.md for migration guide"
        echo ""
        echo "If this is a legitimate exception, add '// ALLOWED: <reason>' comment on the same line"
        FAILED=1
    else
        echo -e "${GREEN}No TypeScript mock violations detected.${NC}"
    fi
fi

# =============================================================================
# Rust Mock Test Violation Detection (Prevention)
# =============================================================================
# Enforces "Real Over Mock" philosophy for Rust tests
# No mock frameworks allowed - use real implementations

RUST_FILES=$(echo "$STAGED_FILES" | grep -E '^server/usm-core/.*\.rs$' || true)
CARGO_FILES=$(echo "$STAGED_FILES" | grep -E 'Cargo\.toml$' || true)

if [ -n "$RUST_FILES" ] || [ -n "$CARGO_FILES" ]; then
    echo -e "\n${YELLOW}Checking for Rust mock test violations...${NC}"

    RUST_MOCK_VIOLATIONS=""

    # Check Cargo.toml for mockall dependency
    for file in $CARGO_FILES; do
        staged_content=$(git show ":$file" 2>/dev/null || true)

        if [ -n "$staged_content" ]; then
            violations=$(echo "$staged_content" | grep -n "mockall" | grep -v "# ALLOWED:" || true)
            if [ -n "$violations" ]; then
                RUST_MOCK_VIOLATIONS="${RUST_MOCK_VIOLATIONS}\n${file} (mockall dependency):\n${violations}"
            fi
        fi
    done

    # Check Rust files for mock patterns
    for file in $RUST_FILES; do
        staged_content=$(git show ":$file" 2>/dev/null || true)

        if [ -n "$staged_content" ]; then
            # Detect mock! macro usage
            mock_macro=$(echo "$staged_content" | grep -n "mock!" | grep -v "// ALLOWED:" || true)
            if [ -n "$mock_macro" ]; then
                RUST_MOCK_VIOLATIONS="${RUST_MOCK_VIOLATIONS}\n${file} (mock! macro):\n${mock_macro}"
            fi

            # Detect struct Mock* definitions
            mock_struct=$(echo "$staged_content" | grep -n "struct Mock" | grep -v "// ALLOWED:" || true)
            if [ -n "$mock_struct" ]; then
                RUST_MOCK_VIOLATIONS="${RUST_MOCK_VIOLATIONS}\n${file} (Mock struct):\n${mock_struct}"
            fi
        fi
    done

    if [ -n "$RUST_MOCK_VIOLATIONS" ]; then
        echo -e "${RED}Rust mock test violations detected!${NC}"
        echo -e "${YELLOW}The following mock patterns were found:${NC}"
        echo -e "$RUST_MOCK_VIOLATIONS"
        echo ""
        echo -e "${YELLOW}TESTING PHILOSOPHY: Real Over Mock${NC}"
        echo "Rust tests should use real implementations, not mocking frameworks."
        echo ""
        echo "Alternatives to mocking:"
        echo "  - Use trait objects with test implementations"
        echo "  - Use conditional compilation (#[cfg(test)])"
        echo "  - Use in-memory storage for database tests"
        echo ""
        echo "See: AGENTS.md for full testing philosophy"
        echo ""
        echo "If this is a legitimate exception, add '// ALLOWED: <reason>' comment on the same line"
        FAILED=1
    else
        echo -e "${GREEN}No Rust mock violations detected.${NC}"
    fi
fi

# =============================================================================
# Dependency Vulnerability Check (Python)
# =============================================================================
# Quick check for known vulnerabilities when requirements files are staged
# Warning only - CI enforces strictly

REQ_FILES=$(echo "$STAGED_FILES" | grep -E 'requirements.*\.txt$' || true)

if [ -n "$REQ_FILES" ]; then
    if command -v pip-audit &> /dev/null; then
        echo -e "\n${YELLOW}Checking Python dependencies for vulnerabilities...${NC}"

        for req in $REQ_FILES; do
            echo "  Scanning $req..."
            vulnerabilities=$(pip-audit -r "$req" --desc 2>/dev/null | grep -c "^Name" || echo 0)
            if [ "$vulnerabilities" -gt 0 ]; then
                echo -e "  ${YELLOW}Warning: Potential vulnerabilities found in $req${NC}"
                echo "  Run 'pip-audit -r $req' for details"
                # Warning only - don't fail the commit
            else
                echo -e "  ${GREEN}No vulnerabilities found in $req${NC}"
            fi
        done
    else
        echo -e "\n${YELLOW}pip-audit not found, skipping Python vulnerability check.${NC}"
        echo "  Install with: pip install pip-audit"
    fi
fi

# =============================================================================
# Dependency Vulnerability Check (Node.js)
# =============================================================================
# Quick check for known vulnerabilities when package files are staged
# Warning only - CI enforces strictly

PACKAGE_FILES=$(echo "$STAGED_FILES" | grep -E '^server/web/package(-lock)?\.json$' || true)
PNPM_FILES=$(echo "$STAGED_FILES" | grep -E '^server/web/pnpm-lock\.yaml$' || true)

if [ -n "$PACKAGE_FILES" ] || [ -n "$PNPM_FILES" ]; then
    if [ -d "server/web" ]; then
        echo -e "\n${YELLOW}Checking Node.js dependencies for vulnerabilities...${NC}"

        cd server/web

        # Try pnpm first (project uses pnpm), then npm
        if command -v pnpm &> /dev/null && [ -f "pnpm-lock.yaml" ]; then
            audit_output=$(pnpm audit --audit-level=high 2>&1 || true)
            if echo "$audit_output" | grep -q "high\|critical"; then
                echo -e "  ${YELLOW}Warning: High/critical vulnerabilities found${NC}"
                echo "  Run 'cd server/web && pnpm audit' for details"
            else
                echo -e "  ${GREEN}No high/critical vulnerabilities found${NC}"
            fi
        elif command -v npm &> /dev/null; then
            audit_output=$(npm audit --audit-level=high 2>&1 || true)
            if echo "$audit_output" | grep -q "high\|critical"; then
                echo -e "  ${YELLOW}Warning: High/critical vulnerabilities found${NC}"
                echo "  Run 'cd server/web && npm audit' for details"
            else
                echo -e "  ${GREEN}No high/critical vulnerabilities found${NC}"
            fi
        else
            echo -e "  ${YELLOW}pnpm/npm not found, skipping Node.js vulnerability check${NC}"
        fi

        cd - > /dev/null
    fi
fi

# =============================================================================
# Secrets Detection (All Files)
# =============================================================================
if command -v gitleaks &> /dev/null; then
    echo -e "\n${YELLOW}Checking for secrets...${NC}"
    gitleaks detect --staged --no-banner --quiet || {
        echo -e "${RED}Gitleaks found potential secrets. Please remove them before committing.${NC}"
        FAILED=1
    }
fi

# =============================================================================
# Final Result
# =============================================================================
echo ""
if [ $FAILED -eq 1 ]; then
    log_hook_execution "FAILED"
    echo -e "${RED}Pre-commit checks failed. Please fix the issues above.${NC}"
    echo -e "${YELLOW}Tip: You can bypass this check with 'git commit --no-verify' (not recommended)${NC}"
    echo -e "${YELLOW}Note: Hook bypasses are logged for audit purposes.${NC}"
    exit 1
else
    log_hook_execution "PASSED"
    echo -e "${GREEN}All pre-commit checks passed!${NC}"
    exit 0
fi
